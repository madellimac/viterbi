----------------------------------------------------------------------------------
-- Company: McGill University, ECE Department
-- Designer: Camille Leroux
-- This HDL Code was generated by a PERL script
-- Generation Date:   Aug. 29 2012    
-- Design Name: Error_count_module_2
-- Module Name:    
-- Description: 
--
 ----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity Error_count_module_2 is
   Port ( rst : in std_logic;
          clk : in std_logic;
          enable : in std_logic;
          comp_1 : in std_logic_vector(1 downto 0);
          comp_2 : in std_logic_vector(1 downto 0);
          BE_Nb : out std_logic_vector(15 downto 0);
          FE_Nb : out std_logic_vector(12 downto 0);
          Bit_Nb : out std_logic_vector(49 downto 0);
          Frame_Nb : out std_logic_vector(47 downto 0);
          BER_LED : out std_logic_vector(1 downto 0);
          overflow_LED : out std_logic_vector(1 downto 0));
end Error_count_module_2;
 
architecture RTL of Error_count_module_2 is



	-- user constants
	constant FrameErrorMax : integer := 100;
	constant BitErrorMax : integer := 65535; -- 13 bits
	constant bit_increment : std_logic_vector(11 downto 0) := "000000000010";

	-- counting constants
	constant val_1_10e4 : std_logic_vector  (56 downto 0) := "000000000000000000000000000000000000000000010011100010000";
	constant val_1_10e5 : std_logic_vector  (56 downto 0) := "000000000000000000000000000000000000000011000011010100000";
		                                               
	constant val_1_10e6 : std_logic_vector  (56 downto 0) := "000000000000000000000000000000000000011110100001001000000";
	constant val_2_10e6 : std_logic_vector  (56 downto 0) := "000000000000000000000000000000000000111101000010010000000";
	constant val_4_10e6 : std_logic_vector  (56 downto 0) := "000000000000000000000000000000000001111010000100100000000";
	constant val_8_10e6 : std_logic_vector  (56 downto 0) := "000000000000000000000000000000000011110100001001000000000";
		                                               
	constant val_1_10e7 : std_logic_vector  (56 downto 0) := "000000000000000000000000000000000100110001001011010000000";
	constant val_2_10e7 : std_logic_vector  (56 downto 0) := "000000000000000000000000000000001001100010010110100000000";
	constant val_4_10e7 : std_logic_vector  (56 downto 0) := "000000000000000000000000000000010011000100101101000000000";
	constant val_8_10e7 : std_logic_vector  (56 downto 0) := "000000000000000000000000000000100110001001011010000000000";
		                                               
	constant val_1_10e8 : std_logic_vector  (56 downto 0) := "000000000000000000000000000000101111101011110000100000000";
	constant val_2_10e8 : std_logic_vector  (56 downto 0) := "000000000000000000000000000001011111010111100001000000000";
	constant val_4_10e8 : std_logic_vector  (56 downto 0) := "000000000000000000000000000010111110101111000010000000000";
	constant val_8_10e8 : std_logic_vector  (56 downto 0) := "000000000000000000000000000101111101011110000100000000000";
		                                               
	constant val_1_10e9 : std_logic_vector  (56 downto 0) := "000000000000000000000000000111011100110101100101000000000";
	constant val_2_10e9 : std_logic_vector  (56 downto 0) := "000000000000000000000000001110111001101011001010000000000";
	constant val_4_10e9 : std_logic_vector  (56 downto 0) := "000000000000000000000000011101110011010110010100000000000";
	constant val_8_10e9 : std_logic_vector  (56 downto 0) := "000000000000000000000000111011100110101100101000000000000";
		                                               
	constant val_1_10e10 : std_logic_vector (56 downto 0) := "000000000000000000000001001010100000010111110010000000000";
	constant val_2_10e10 : std_logic_vector (56 downto 0) := "000000000000000000000010010101000000101111100100000000000";
	constant val_4_10e10 : std_logic_vector (56 downto 0) := "000000000000000000000100101010000001011111001000000000000";
	constant val_8_10e10 : std_logic_vector (56 downto 0) := "000000000000000000001001010100000010111110010000000000000";
		                                               
	constant val_1_10e11 : std_logic_vector (56 downto 0) := "000000000000000000001011101001000011101101110100000000000";
	constant val_2_10e11 : std_logic_vector (56 downto 0) := "000000000000000000010111010010000111011011101000000000000";
	constant val_4_10e11 : std_logic_vector (56 downto 0) := "000000000000000000101110100100001110110111010000000000000";
	constant val_8_10e11 : std_logic_vector (56 downto 0) := "000000000000000001011101001000011101101110100000000000000";
		                                               
	constant val_1_10e12 : std_logic_vector (56 downto 0) := "000000000000000001110100011010100101001010001000000000000";
	constant val_2_10e12 : std_logic_vector (56 downto 0) := "000000000000000011101000110101001010010100010000000000000";
	constant val_4_10e12 : std_logic_vector (56 downto 0) := "000000000000000111010001101010010100101000100000000000000";
	constant val_8_10e12 : std_logic_vector (56 downto 0) := "000000000000001110100011010100101001010001000000000000000";
		                                               
	constant val_1_10e13 : std_logic_vector (56 downto 0) := "000000000000010010001100001001110011100101010000000000000";
	constant val_2_10e13 : std_logic_vector (56 downto 0) := "000000000000100100011000010011100111001010100000000000000";
	constant val_4_10e13 : std_logic_vector (56 downto 0) := "000000000001001000110000100111001110010101000000000000000";
	constant val_8_10e13 : std_logic_vector (56 downto 0) := "000000000010010001100001001110011100101010000000000000000";
		                                               
	constant val_1_10e14 : std_logic_vector (56 downto 0) := "000000000010110101111001100010000011110100100000000000000";
	constant val_2_10e14 : std_logic_vector (56 downto 0) := "000000000101101011110011000100000111101001000000000000000";
	constant val_4_10e14 : std_logic_vector (56 downto 0) := "000000001011010111100110001000001111010010000000000000000";
	constant val_8_10e14 : std_logic_vector (56 downto 0) := "000000010110101111001100010000011110100100000000000000000";

	constant val_1_10e15 : std_logic_vector (56 downto 0) := "000000011100011010111111010100100110001101000000000000000";
	constant val_2_10e15 : std_logic_vector (56 downto 0) := "000000111000110101111110101001001100011010000000000000000";
	constant val_4_10e15 : std_logic_vector (56 downto 0) := "000001110001101011111101010010011000110100000000000000000";
	constant val_8_10e15 : std_logic_vector (56 downto 0) := "000011100011010111111010100100110001101000000000000000000";

	constant val_1_10e16 : std_logic_vector (56 downto 0) := "000100011100001101111001001101111110000010000000000000000";
	constant val_2_10e16 : std_logic_vector (56 downto 0) := "001000111000011011110010011011111100000100000000000000000";
	constant val_4_10e16 : std_logic_vector (56 downto 0) := "010001110000110111100100110111111000001000000000000000000";
	constant val_8_10e16 : std_logic_vector (56 downto 0) := "100011100001101111001001101111110000010000000000000000000";

	-- LED states, NB: MSB must be connected to the red LEDs and LSB to the green LEDs
	constant red : std_logic_vector := "10";
	constant green : std_logic_vector := "01";
	constant yellow : std_logic_vector := "11";
	constant off : std_logic_vector := "00";

-- state machine declaration
type state_type is (ber_compute_st, overflow_st, ber_ok_st); 
signal state, next_state : state_type; 

signal bit_counter : std_logic_vector(49 downto 0);
signal enable_dly, en_counting, falling_edge_enable, FrameErrorNb_tmp : std_logic;
signal FrameErrorNb : std_logic_vector(12 downto 0);
signal BitErrorNb, accu_xor : std_logic_vector(15 downto 0);
signal overflow_val, before_xor_after : std_logic_vector(1 downto 0);
signal frame_counter : std_logic_vector(47 downto 0);


begin


	Frame_Nb <= frame_counter;
	Bit_Nb <= bit_counter;
	BE_Nb <= BitErrorNb;
	FE_Nb <= FrameErrorNb;
	-- counting overflow detection
	overflow_proc : process(BitErrorNb, bit_counter)
	begin
		if (BitErrorNb > BitErrorMax) then
			overflow_val <= green;
		elsif(bit_counter > val_8_10e16) then
			overflow_val <= red;
		else
			overflow_val <= off;
		end if;
	end process;

	SYNC_PROC: process (clk,rst)
	begin
		if(rst = '1') then
			state <= ber_compute_st;
	elsif (clk'event and clk = '1') then
			if(enable = '1') then
				state <= next_state;
			end if;
	end if;
	end process;
 
	--MOORE State-Machine - Outputs based on state only
	OUTPUT_DECODE: process (state, overflow_val)
	begin
	if (state = ber_compute_st) then
	   overflow_LED <= off;
			BER_LED <= red;
			en_counting <= '1';
	elsif(state = overflow_st) then
	   overflow_LED <= overflow_val; -- green : bit error count OF / red : data count OF
			BER_LED <= red;
			en_counting <= '0';		
		else -- state = ber_ok_st
			overflow_LED <= off;
			BER_LED <= green;
			en_counting <= '0';
	end if;
	end process;

	NEXT_STATE_DECODE: process (state, overflow_val, FrameErrorNb)
	begin
	case (state) is
	   when ber_compute_st => -- BER is being computed
		if (overflow_val /= "00") then
		   next_state <= overflow_st;
				elsif(FrameErrorNb > FrameErrorMax) then
					next_state <= ber_ok_st;
				else
					next_state <= ber_compute_st;
		end if;         	
	   when ber_ok_st => -- BER is updated and reliable
		next_state <= ber_ok_st;			
			when others => -- overflow_st : overflow detected : OF_LED=red => data counter OF,  OF_LEd=green => error counter OF
		next_state <= overflow_st;
	end case;      
	end process;

	-- data counter which keeps track of the number of transmitted data
	data_counter_proc: process(rst,clk)
	begin
		if(rst= '1') then
			bit_counter <= (others=> '0');
			
		elsif(clk'event and clk = '1') then
			if(enable = '1' and en_counting = '1') then
				bit_counter <= bit_counter + bit_increment;				
			end if;
		end if;
	end process;

	-- input vectors comparison
	before_xor_after <= comp_1 xor comp_2;

	-- enable falling edge detection
	enable_dly_proc : process(rst,clk)
	begin
		if(rst = '1') then
			enable_dly <= '0';
		elsif(clk'event and clk = '1') then
			enable_dly <= enable;
		end if;
	end process;

	falling_edge_enable <= not(enable) and enable_dly;

accu_xor <= ("000000000000000"&before_xor_after(0)) + ("000000000000000"&before_xor_after(1)) ;

-- error counting
error_count : process(rst,clk) 
begin
	if (rst = '1') then
		BitErrorNb <= (others => '0');
		FrameErrorNb_tmp <= '0';
		FrameErrorNb  <= (others => '0');
		frame_counter <= (others=> '0');
	elsif(clk'event and clk = '1') then
		if(enable = '1' and en_counting = '1') then
		BitErrorNb <= BitErrorNb + accu_xor;
FrameErrorNb_tmp <= FrameErrorNb_tmp or before_xor_after(0) or before_xor_after(1) ;

		else
			BitErrorNb <= BitErrorNb;
			FrameErrorNb_tmp <= '0';
		end if;
		if(falling_edge_enable = '1' and en_counting = '1') then
			FrameErrorNb <= FrameErrorNb + FrameErrorNb_tmp;
			frame_counter <= frame_counter + 1;
		else
			FrameErrorNb <= FrameErrorNb;
			frame_counter <= frame_counter;
		end if;
	end if;
end process;

end RTL;
